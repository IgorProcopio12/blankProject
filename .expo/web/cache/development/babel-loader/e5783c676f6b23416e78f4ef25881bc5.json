{"ast":null,"code":"import { isStartish, isMoveish, isEndish } from \"./ResponderEventTypes\";\n\nvar __DEV__ = process.env.NODE_ENV !== 'production';\n\nvar MAX_TOUCH_BANK = 20;\nvar touchBank = [];\nvar touchHistory = {\n  touchBank: touchBank,\n  numberActiveTouches: 0,\n  indexOfSingleActiveTouch: -1,\n  mostRecentTimeStamp: 0\n};\n\nfunction timestampForTouch(touch) {\n  return touch.timeStamp || touch.timestamp;\n}\n\nfunction createTouchRecord(touch) {\n  return {\n    touchActive: true,\n    startPageX: touch.pageX,\n    startPageY: touch.pageY,\n    startTimeStamp: timestampForTouch(touch),\n    currentPageX: touch.pageX,\n    currentPageY: touch.pageY,\n    currentTimeStamp: timestampForTouch(touch),\n    previousPageX: touch.pageX,\n    previousPageY: touch.pageY,\n    previousTimeStamp: timestampForTouch(touch)\n  };\n}\n\nfunction resetTouchRecord(touchRecord, touch) {\n  touchRecord.touchActive = true;\n  touchRecord.startPageX = touch.pageX;\n  touchRecord.startPageY = touch.pageY;\n  touchRecord.startTimeStamp = timestampForTouch(touch);\n  touchRecord.currentPageX = touch.pageX;\n  touchRecord.currentPageY = touch.pageY;\n  touchRecord.currentTimeStamp = timestampForTouch(touch);\n  touchRecord.previousPageX = touch.pageX;\n  touchRecord.previousPageY = touch.pageY;\n  touchRecord.previousTimeStamp = timestampForTouch(touch);\n}\n\nfunction getTouchIdentifier(_ref) {\n  var identifier = _ref.identifier;\n\n  if (identifier == null) {\n    console.error('Touch object is missing identifier.');\n  }\n\n  if (__DEV__) {\n    if (identifier > MAX_TOUCH_BANK) {\n      console.error('Touch identifier %s is greater than maximum supported %s which causes ' + 'performance issues backfilling array locations for all of the indices.', identifier, MAX_TOUCH_BANK);\n    }\n  }\n\n  return identifier;\n}\n\nfunction recordTouchStart(touch) {\n  var identifier = getTouchIdentifier(touch);\n  var touchRecord = touchBank[identifier];\n\n  if (touchRecord) {\n    resetTouchRecord(touchRecord, touch);\n  } else {\n    touchBank[identifier] = createTouchRecord(touch);\n  }\n\n  touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n}\n\nfunction recordTouchMove(touch) {\n  var touchRecord = touchBank[getTouchIdentifier(touch)];\n\n  if (touchRecord) {\n    touchRecord.touchActive = true;\n    touchRecord.previousPageX = touchRecord.currentPageX;\n    touchRecord.previousPageY = touchRecord.currentPageY;\n    touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n    touchRecord.currentPageX = touch.pageX;\n    touchRecord.currentPageY = touch.pageY;\n    touchRecord.currentTimeStamp = timestampForTouch(touch);\n    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n  } else {\n    console.warn('Cannot record touch move without a touch start.\\n', \"Touch Move: \" + printTouch(touch) + \"\\n\", \"Touch Bank: \" + printTouchBank());\n  }\n}\n\nfunction recordTouchEnd(touch) {\n  var touchRecord = touchBank[getTouchIdentifier(touch)];\n\n  if (touchRecord) {\n    touchRecord.touchActive = false;\n    touchRecord.previousPageX = touchRecord.currentPageX;\n    touchRecord.previousPageY = touchRecord.currentPageY;\n    touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n    touchRecord.currentPageX = touch.pageX;\n    touchRecord.currentPageY = touch.pageY;\n    touchRecord.currentTimeStamp = timestampForTouch(touch);\n    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n  } else {\n    console.warn('Cannot record touch end without a touch start.\\n', \"Touch End: \" + printTouch(touch) + \"\\n\", \"Touch Bank: \" + printTouchBank());\n  }\n}\n\nfunction printTouch(touch) {\n  return JSON.stringify({\n    identifier: touch.identifier,\n    pageX: touch.pageX,\n    pageY: touch.pageY,\n    timestamp: timestampForTouch(touch)\n  });\n}\n\nfunction printTouchBank() {\n  var printed = JSON.stringify(touchBank.slice(0, MAX_TOUCH_BANK));\n\n  if (touchBank.length > MAX_TOUCH_BANK) {\n    printed += ' (original size: ' + touchBank.length + ')';\n  }\n\n  return printed;\n}\n\nvar ResponderTouchHistoryStore = {\n  recordTouchTrack: function recordTouchTrack(topLevelType, nativeEvent) {\n    if (isMoveish(topLevelType)) {\n      nativeEvent.changedTouches.forEach(recordTouchMove);\n    } else if (isStartish(topLevelType)) {\n      nativeEvent.changedTouches.forEach(recordTouchStart);\n      touchHistory.numberActiveTouches = nativeEvent.touches.length;\n\n      if (touchHistory.numberActiveTouches === 1) {\n        touchHistory.indexOfSingleActiveTouch = nativeEvent.touches[0].identifier;\n      }\n    } else if (isEndish(topLevelType)) {\n      nativeEvent.changedTouches.forEach(recordTouchEnd);\n      touchHistory.numberActiveTouches = nativeEvent.touches.length;\n\n      if (touchHistory.numberActiveTouches === 1) {\n        for (var i = 0; i < touchBank.length; i++) {\n          var touchTrackToCheck = touchBank[i];\n\n          if (touchTrackToCheck != null && touchTrackToCheck.touchActive) {\n            touchHistory.indexOfSingleActiveTouch = i;\n            break;\n          }\n        }\n\n        if (__DEV__) {\n          var activeRecord = touchBank[touchHistory.indexOfSingleActiveTouch];\n\n          if (!(activeRecord != null && activeRecord.touchActive)) {\n            console.error('Cannot find single active touch.');\n          }\n        }\n      }\n    }\n  },\n  touchHistory: touchHistory\n};\nexport default ResponderTouchHistoryStore;","map":{"version":3,"sources":["C:/git/blankProject/node_modules/react-native-web/src/hooks/useResponderEvents/ResponderTouchHistoryStore.js"],"names":["isStartish","isMoveish","isEndish","__DEV__","process","env","NODE_ENV","MAX_TOUCH_BANK","touchBank","touchHistory","numberActiveTouches","indexOfSingleActiveTouch","mostRecentTimeStamp","timestampForTouch","touch","timeStamp","timestamp","createTouchRecord","touchActive","startPageX","pageX","startPageY","pageY","startTimeStamp","currentPageX","currentPageY","currentTimeStamp","previousPageX","previousPageY","previousTimeStamp","resetTouchRecord","touchRecord","getTouchIdentifier","identifier","console","error","recordTouchStart","recordTouchMove","warn","printTouch","printTouchBank","recordTouchEnd","JSON","stringify","printed","slice","length","ResponderTouchHistoryStore","recordTouchTrack","topLevelType","nativeEvent","changedTouches","forEach","touches","i","touchTrackToCheck","activeRecord"],"mappings":"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","sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\nimport type { Touch, TouchEvent } from './ResponderEventTypes';\r\nimport { isStartish, isMoveish, isEndish } from './ResponderEventTypes';\r\n\r\ntype TouchRecord = {|\r\n  touchActive: boolean,\r\n  startPageX: number,\r\n  startPageY: number,\r\n  startTimeStamp: number,\r\n  currentPageX: number,\r\n  currentPageY: number,\r\n  currentTimeStamp: number,\r\n  previousPageX: number,\r\n  previousPageY: number,\r\n  previousTimeStamp: number\r\n|};\r\n\r\n/**\r\n * Tracks the position and time of each active touch by `touch.identifier`. We\r\n * should typically only see IDs in the range of 1-20 because IDs get recycled\r\n * when touches end and start again.\r\n */\r\n\r\nconst __DEV__ = process.env.NODE_ENV !== 'production';\r\nconst MAX_TOUCH_BANK = 20;\r\nconst touchBank: Array<TouchRecord> = [];\r\nconst touchHistory = {\r\n  touchBank,\r\n  numberActiveTouches: 0,\r\n  // If there is only one active touch, we remember its location. This prevents\r\n  // us having to loop through all of the touches all the time in the most\r\n  // common case.\r\n  indexOfSingleActiveTouch: -1,\r\n  mostRecentTimeStamp: 0\r\n};\r\n\r\nfunction timestampForTouch(touch: Touch): number {\r\n  // The legacy internal implementation provides \"timeStamp\", which has been\r\n  // renamed to \"timestamp\".\r\n  return (touch: any).timeStamp || touch.timestamp;\r\n}\r\n\r\n/**\r\n * TODO: Instead of making gestures recompute filtered velocity, we could\r\n * include a built in velocity computation that can be reused globally.\r\n */\r\nfunction createTouchRecord(touch: Touch): TouchRecord {\r\n  return {\r\n    touchActive: true,\r\n    startPageX: touch.pageX,\r\n    startPageY: touch.pageY,\r\n    startTimeStamp: timestampForTouch(touch),\r\n    currentPageX: touch.pageX,\r\n    currentPageY: touch.pageY,\r\n    currentTimeStamp: timestampForTouch(touch),\r\n    previousPageX: touch.pageX,\r\n    previousPageY: touch.pageY,\r\n    previousTimeStamp: timestampForTouch(touch)\r\n  };\r\n}\r\n\r\nfunction resetTouchRecord(touchRecord: TouchRecord, touch: Touch): void {\r\n  touchRecord.touchActive = true;\r\n  touchRecord.startPageX = touch.pageX;\r\n  touchRecord.startPageY = touch.pageY;\r\n  touchRecord.startTimeStamp = timestampForTouch(touch);\r\n  touchRecord.currentPageX = touch.pageX;\r\n  touchRecord.currentPageY = touch.pageY;\r\n  touchRecord.currentTimeStamp = timestampForTouch(touch);\r\n  touchRecord.previousPageX = touch.pageX;\r\n  touchRecord.previousPageY = touch.pageY;\r\n  touchRecord.previousTimeStamp = timestampForTouch(touch);\r\n}\r\n\r\nfunction getTouchIdentifier({ identifier }: Touch): number {\r\n  if (identifier == null) {\r\n    console.error('Touch object is missing identifier.');\r\n  }\r\n  if (__DEV__) {\r\n    if (identifier > MAX_TOUCH_BANK) {\r\n      console.error(\r\n        'Touch identifier %s is greater than maximum supported %s which causes ' +\r\n          'performance issues backfilling array locations for all of the indices.',\r\n        identifier,\r\n        MAX_TOUCH_BANK\r\n      );\r\n    }\r\n  }\r\n  return identifier;\r\n}\r\n\r\nfunction recordTouchStart(touch: Touch): void {\r\n  const identifier = getTouchIdentifier(touch);\r\n  const touchRecord = touchBank[identifier];\r\n  if (touchRecord) {\r\n    resetTouchRecord(touchRecord, touch);\r\n  } else {\r\n    touchBank[identifier] = createTouchRecord(touch);\r\n  }\r\n  touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\r\n}\r\n\r\nfunction recordTouchMove(touch: Touch): void {\r\n  const touchRecord = touchBank[getTouchIdentifier(touch)];\r\n  if (touchRecord) {\r\n    touchRecord.touchActive = true;\r\n    touchRecord.previousPageX = touchRecord.currentPageX;\r\n    touchRecord.previousPageY = touchRecord.currentPageY;\r\n    touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\r\n    touchRecord.currentPageX = touch.pageX;\r\n    touchRecord.currentPageY = touch.pageY;\r\n    touchRecord.currentTimeStamp = timestampForTouch(touch);\r\n    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\r\n  } else {\r\n    console.warn(\r\n      'Cannot record touch move without a touch start.\\n',\r\n      `Touch Move: ${printTouch(touch)}\\n`,\r\n      `Touch Bank: ${printTouchBank()}`\r\n    );\r\n  }\r\n}\r\n\r\nfunction recordTouchEnd(touch: Touch): void {\r\n  const touchRecord = touchBank[getTouchIdentifier(touch)];\r\n  if (touchRecord) {\r\n    touchRecord.touchActive = false;\r\n    touchRecord.previousPageX = touchRecord.currentPageX;\r\n    touchRecord.previousPageY = touchRecord.currentPageY;\r\n    touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\r\n    touchRecord.currentPageX = touch.pageX;\r\n    touchRecord.currentPageY = touch.pageY;\r\n    touchRecord.currentTimeStamp = timestampForTouch(touch);\r\n    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\r\n  } else {\r\n    console.warn(\r\n      'Cannot record touch end without a touch start.\\n',\r\n      `Touch End: ${printTouch(touch)}\\n`,\r\n      `Touch Bank: ${printTouchBank()}`\r\n    );\r\n  }\r\n}\r\n\r\nfunction printTouch(touch: Touch): string {\r\n  return JSON.stringify({\r\n    identifier: touch.identifier,\r\n    pageX: touch.pageX,\r\n    pageY: touch.pageY,\r\n    timestamp: timestampForTouch(touch)\r\n  });\r\n}\r\n\r\nfunction printTouchBank(): string {\r\n  let printed = JSON.stringify(touchBank.slice(0, MAX_TOUCH_BANK));\r\n  if (touchBank.length > MAX_TOUCH_BANK) {\r\n    printed += ' (original size: ' + touchBank.length + ')';\r\n  }\r\n  return printed;\r\n}\r\n\r\nconst ResponderTouchHistoryStore = {\r\n  recordTouchTrack(topLevelType: string, nativeEvent: TouchEvent): void {\r\n    if (isMoveish(topLevelType)) {\r\n      nativeEvent.changedTouches.forEach(recordTouchMove);\r\n    } else if (isStartish(topLevelType)) {\r\n      nativeEvent.changedTouches.forEach(recordTouchStart);\r\n      touchHistory.numberActiveTouches = nativeEvent.touches.length;\r\n      if (touchHistory.numberActiveTouches === 1) {\r\n        touchHistory.indexOfSingleActiveTouch = nativeEvent.touches[0].identifier;\r\n      }\r\n    } else if (isEndish(topLevelType)) {\r\n      nativeEvent.changedTouches.forEach(recordTouchEnd);\r\n      touchHistory.numberActiveTouches = nativeEvent.touches.length;\r\n      if (touchHistory.numberActiveTouches === 1) {\r\n        for (let i = 0; i < touchBank.length; i++) {\r\n          const touchTrackToCheck = touchBank[i];\r\n          if (touchTrackToCheck != null && touchTrackToCheck.touchActive) {\r\n            touchHistory.indexOfSingleActiveTouch = i;\r\n            break;\r\n          }\r\n        }\r\n        if (__DEV__) {\r\n          const activeRecord = touchBank[touchHistory.indexOfSingleActiveTouch];\r\n          if (!(activeRecord != null && activeRecord.touchActive)) {\r\n            console.error('Cannot find single active touch.');\r\n          }\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  touchHistory\r\n};\r\n\r\nexport default ResponderTouchHistoryStore;\r\n"]},"metadata":{},"sourceType":"module"}