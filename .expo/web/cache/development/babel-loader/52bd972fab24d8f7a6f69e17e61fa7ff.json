{"ast":null,"code":"import isSelectionValid from \"../../modules/isSelectionValid\";\nvar keyName = '__reactResponderId';\n\nfunction getEventPath(domEvent) {\n  if (domEvent.type === 'selectionchange') {\n    var target = window.getSelection().anchorNode;\n    return composedPathFallback(target);\n  } else {\n    var path = domEvent.composedPath != null ? domEvent.composedPath() : composedPathFallback(domEvent.target);\n    return path;\n  }\n}\n\nfunction composedPathFallback(target) {\n  var path = [];\n\n  while (target != null && target !== document.body) {\n    path.push(target);\n    target = target.parentNode;\n  }\n\n  return path;\n}\n\nfunction getResponderId(node) {\n  if (node != null) {\n    return node[keyName];\n  }\n\n  return null;\n}\n\nexport function setResponderId(node, id) {\n  if (node != null) {\n    node[keyName] = id;\n  }\n}\nexport function getResponderPaths(domEvent) {\n  var idPath = [];\n  var nodePath = [];\n  var eventPath = getEventPath(domEvent);\n\n  for (var i = 0; i < eventPath.length; i++) {\n    var node = eventPath[i];\n    var id = getResponderId(node);\n\n    if (id != null) {\n      idPath.push(id);\n      nodePath.push(node);\n    }\n  }\n\n  return {\n    idPath: idPath,\n    nodePath: nodePath\n  };\n}\nexport function getLowestCommonAncestor(pathA, pathB) {\n  var pathALength = pathA.length;\n  var pathBLength = pathB.length;\n\n  if (pathALength === 0 || pathBLength === 0 || pathA[pathALength - 1] !== pathB[pathBLength - 1]) {\n    return null;\n  }\n\n  var itemA = pathA[0];\n  var indexA = 0;\n  var itemB = pathB[0];\n  var indexB = 0;\n\n  if (pathALength - pathBLength > 0) {\n    indexA = pathALength - pathBLength;\n    itemA = pathA[indexA];\n    pathALength = pathBLength;\n  }\n\n  if (pathBLength - pathALength > 0) {\n    indexB = pathBLength - pathALength;\n    itemB = pathB[indexB];\n    pathBLength = pathALength;\n  }\n\n  var depth = pathALength;\n\n  while (depth--) {\n    if (itemA === itemB) {\n      return itemA;\n    }\n\n    itemA = pathA[indexA++];\n    itemB = pathB[indexB++];\n  }\n\n  return null;\n}\nexport function hasTargetTouches(target, touches) {\n  if (!touches || touches.length === 0) {\n    return false;\n  }\n\n  for (var i = 0; i < touches.length; i++) {\n    var node = touches[i].target;\n\n    if (node != null) {\n      if (target.contains(node)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\nexport function hasValidSelection(domEvent) {\n  if (domEvent.type === 'selectionchange') {\n    return isSelectionValid();\n  }\n\n  return domEvent.type === 'select';\n}\nexport function isPrimaryPointerDown(domEvent) {\n  var altKey = domEvent.altKey,\n      button = domEvent.button,\n      buttons = domEvent.buttons,\n      ctrlKey = domEvent.ctrlKey,\n      type = domEvent.type;\n  var isTouch = type === 'touchstart' || type === 'touchmove';\n  var isPrimaryMouseDown = type === 'mousedown' && (button === 0 || buttons === 1);\n  var isPrimaryMouseMove = type === 'mousemove' && buttons === 1;\n  var noModifiers = altKey === false && ctrlKey === false;\n\n  if (isTouch || isPrimaryMouseDown && noModifiers || isPrimaryMouseMove && noModifiers) {\n    return true;\n  }\n\n  return false;\n}","map":{"version":3,"sources":["C:/git/blankProject/node_modules/react-native-web/src/hooks/useResponderEvents/utils.js"],"names":["isSelectionValid","keyName","getEventPath","domEvent","type","target","window","getSelection","anchorNode","composedPathFallback","path","composedPath","document","body","push","parentNode","getResponderId","node","setResponderId","id","getResponderPaths","idPath","nodePath","eventPath","i","length","getLowestCommonAncestor","pathA","pathB","pathALength","pathBLength","itemA","indexA","itemB","indexB","depth","hasTargetTouches","touches","contains","hasValidSelection","isPrimaryPointerDown","altKey","button","buttons","ctrlKey","isTouch","isPrimaryMouseDown","isPrimaryMouseMove","noModifiers"],"mappings":"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","sourcesContent":["/**\r\n * Copyright (c) Nicolas Gallagher\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\nimport isSelectionValid from '../../modules/isSelectionValid';\r\n\r\nconst keyName = '__reactResponderId';\r\n\r\nfunction getEventPath(domEvent: any): Array<any> {\r\n  // The 'selectionchange' event always has the 'document' as the target.\r\n  // Use the anchor node as the initial target to reconstruct a path.\r\n  // (We actually only need the first \"responder\" node in practice.)\r\n  if (domEvent.type === 'selectionchange') {\r\n    const target = window.getSelection().anchorNode;\r\n    return composedPathFallback(target);\r\n  } else {\r\n    const path =\r\n      domEvent.composedPath != null\r\n        ? domEvent.composedPath()\r\n        : composedPathFallback(domEvent.target);\r\n    return path;\r\n  }\r\n}\r\n\r\nfunction composedPathFallback(target: any): Array<any> {\r\n  const path = [];\r\n  while (target != null && target !== document.body) {\r\n    path.push(target);\r\n    target = target.parentNode;\r\n  }\r\n  return path;\r\n}\r\n\r\n/**\r\n * Retrieve the responderId from a host node\r\n */\r\nfunction getResponderId(node: any): ?number {\r\n  if (node != null) {\r\n    return node[keyName];\r\n  }\r\n  return null;\r\n}\r\n\r\n/**\r\n * Store the responderId on a host node\r\n */\r\nexport function setResponderId(node: any, id: number) {\r\n  if (node != null) {\r\n    node[keyName] = id;\r\n  }\r\n}\r\n\r\n/**\r\n * Filter the event path to contain only the nodes attached to the responder system\r\n */\r\nexport function getResponderPaths(\r\n  domEvent: any\r\n): {| idPath: Array<number>, nodePath: Array<any> |} {\r\n  const idPath = [];\r\n  const nodePath = [];\r\n  const eventPath = getEventPath(domEvent);\r\n  for (let i = 0; i < eventPath.length; i++) {\r\n    const node = eventPath[i];\r\n    const id = getResponderId(node);\r\n    if (id != null) {\r\n      idPath.push(id);\r\n      nodePath.push(node);\r\n    }\r\n  }\r\n  return { idPath, nodePath };\r\n}\r\n\r\n/**\r\n * Walk the paths and find the first common ancestor\r\n */\r\nexport function getLowestCommonAncestor(pathA: Array<any>, pathB: Array<any>) {\r\n  let pathALength = pathA.length;\r\n  let pathBLength = pathB.length;\r\n  if (\r\n    // If either path is empty\r\n    pathALength === 0 ||\r\n    pathBLength === 0 ||\r\n    // If the last elements aren't the same there can't be a common ancestor\r\n    // that is connected to the responder system\r\n    pathA[pathALength - 1] !== pathB[pathBLength - 1]\r\n  ) {\r\n    return null;\r\n  }\r\n\r\n  let itemA = pathA[0];\r\n  let indexA = 0;\r\n  let itemB = pathB[0];\r\n  let indexB = 0;\r\n\r\n  // If A is deeper, skip indices that can't match.\r\n  if (pathALength - pathBLength > 0) {\r\n    indexA = pathALength - pathBLength;\r\n    itemA = pathA[indexA];\r\n    pathALength = pathBLength;\r\n  }\r\n\r\n  // If B is deeper, skip indices that can't match\r\n  if (pathBLength - pathALength > 0) {\r\n    indexB = pathBLength - pathALength;\r\n    itemB = pathB[indexB];\r\n    pathBLength = pathALength;\r\n  }\r\n\r\n  // Walk in lockstep until a match is found\r\n  let depth = pathALength;\r\n  while (depth--) {\r\n    if (itemA === itemB) {\r\n      return itemA;\r\n    }\r\n    itemA = pathA[indexA++];\r\n    itemB = pathB[indexB++];\r\n  }\r\n  return null;\r\n}\r\n\r\n/**\r\n * Determine whether any of the active touches are within the current responder.\r\n * This cannot rely on W3C `targetTouches`, as neither IE11 nor Safari implement it.\r\n */\r\nexport function hasTargetTouches(target: any, touches: any): boolean {\r\n  if (!touches || touches.length === 0) {\r\n    return false;\r\n  }\r\n  for (let i = 0; i < touches.length; i++) {\r\n    const node = touches[i].target;\r\n    if (node != null) {\r\n      if (target.contains(node)) {\r\n        return true;\r\n      }\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\n/**\r\n * Ignore 'selectionchange' events that don't correspond with a person's intent to\r\n * select text.\r\n */\r\nexport function hasValidSelection(domEvent: any) {\r\n  if (domEvent.type === 'selectionchange') {\r\n    return isSelectionValid();\r\n  }\r\n  return domEvent.type === 'select';\r\n}\r\n\r\n/**\r\n * Events are only valid if the primary button was used without specific modifier keys.\r\n */\r\nexport function isPrimaryPointerDown(domEvent: any): boolean {\r\n  const { altKey, button, buttons, ctrlKey, type } = domEvent;\r\n  const isTouch = type === 'touchstart' || type === 'touchmove';\r\n  const isPrimaryMouseDown = type === 'mousedown' && (button === 0 || buttons === 1);\r\n  const isPrimaryMouseMove = type === 'mousemove' && buttons === 1;\r\n  const noModifiers = altKey === false && ctrlKey === false;\r\n\r\n  if (isTouch || (isPrimaryMouseDown && noModifiers) || (isPrimaryMouseMove && noModifiers)) {\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}