{"ast":null,"code":"var slice = Array.prototype.slice;\nexport default function createOrderedCSSStyleSheet(sheet) {\n  var groups = {};\n  var selectors = {};\n\n  if (sheet != null) {\n    var group;\n    slice.call(sheet.cssRules).forEach(function (cssRule, i) {\n      var cssText = cssRule.cssText;\n\n      if (cssText.indexOf('stylesheet-group') > -1) {\n        group = decodeGroupRule(cssRule);\n        groups[group] = {\n          start: i,\n          rules: [cssText]\n        };\n      } else {\n        var selectorText = getSelectorText(cssText);\n\n        if (selectorText != null) {\n          selectors[selectorText] = true;\n          groups[group].rules.push(cssText);\n        }\n      }\n    });\n  }\n\n  function sheetInsert(sheet, group, text) {\n    var orderedGroups = getOrderedGroups(groups);\n    var groupIndex = orderedGroups.indexOf(group);\n    var nextGroupIndex = groupIndex + 1;\n    var nextGroup = orderedGroups[nextGroupIndex];\n    var position = nextGroup != null && groups[nextGroup].start != null ? groups[nextGroup].start : sheet.cssRules.length;\n    var isInserted = insertRuleAt(sheet, text, position);\n\n    if (isInserted) {\n      if (groups[group].start == null) {\n        groups[group].start = position;\n      }\n\n      for (var i = nextGroupIndex; i < orderedGroups.length; i += 1) {\n        var groupNumber = orderedGroups[i];\n        var previousStart = groups[groupNumber].start;\n        groups[groupNumber].start = previousStart + 1;\n      }\n    }\n\n    return isInserted;\n  }\n\n  var OrderedCSSStyleSheet = {\n    getTextContent: function getTextContent() {\n      return getOrderedGroups(groups).map(function (group) {\n        var rules = groups[group].rules;\n        return rules.join('\\n');\n      }).join('\\n');\n    },\n    insert: function insert(cssText, groupValue) {\n      var group = Number(groupValue);\n\n      if (groups[group] == null) {\n        var markerRule = encodeGroupRule(group);\n        groups[group] = {\n          start: null,\n          rules: [markerRule]\n        };\n\n        if (sheet != null) {\n          sheetInsert(sheet, group, markerRule);\n        }\n      }\n\n      var selectorText = getSelectorText(cssText);\n\n      if (selectorText != null && selectors[selectorText] == null) {\n        selectors[selectorText] = true;\n        groups[group].rules.push(cssText);\n\n        if (sheet != null) {\n          var isInserted = sheetInsert(sheet, group, cssText);\n\n          if (!isInserted) {\n            groups[group].rules.pop();\n          }\n        }\n      }\n    }\n  };\n  return OrderedCSSStyleSheet;\n}\n\nfunction encodeGroupRule(group) {\n  return \"[stylesheet-group=\\\"\" + group + \"\\\"]{}\";\n}\n\nfunction decodeGroupRule(cssRule) {\n  return Number(cssRule.selectorText.split(/[\"']/)[1]);\n}\n\nfunction getOrderedGroups(obj) {\n  return Object.keys(obj).map(Number).sort(function (a, b) {\n    return a > b ? 1 : -1;\n  });\n}\n\nvar pattern = /\\s*([,])\\s*/g;\n\nfunction getSelectorText(cssText) {\n  var selector = cssText.split('{')[0].trim();\n  return selector !== '' ? selector.replace(pattern, '$1') : null;\n}\n\nfunction insertRuleAt(root, cssText, position) {\n  try {\n    root.insertRule(cssText, position);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}","map":{"version":3,"sources":["C:/git/blankProject/node_modules/react-native-web/src/exports/StyleSheet/createOrderedCSSStyleSheet.js"],"names":["slice","Array","prototype","createOrderedCSSStyleSheet","sheet","groups","selectors","group","call","cssRules","forEach","cssRule","i","cssText","indexOf","decodeGroupRule","start","rules","selectorText","getSelectorText","push","sheetInsert","text","orderedGroups","getOrderedGroups","groupIndex","nextGroupIndex","nextGroup","position","length","isInserted","insertRuleAt","groupNumber","previousStart","OrderedCSSStyleSheet","getTextContent","map","join","insert","groupValue","Number","markerRule","encodeGroupRule","pop","split","obj","Object","keys","sort","a","b","pattern","selector","trim","replace","root","insertRule","e"],"mappings":"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","sourcesContent":["/**\r\n * Copyright (c) Nicolas Gallagher.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow strict-local\r\n */\r\n\r\ntype Groups = { [key: number]: { start: ?number, rules: Array<string> } };\r\ntype Selectors = { [key: string]: boolean };\r\n\r\nconst slice = Array.prototype.slice;\r\n\r\n/**\r\n * Order-based insertion of CSS.\r\n *\r\n * Each rule is associated with a numerically defined group.\r\n * Groups are ordered within the style sheet according to their number, with the\r\n * lowest first.\r\n *\r\n * Groups are implemented using marker rules. The selector of the first rule of\r\n * each group is used only to encode the group number for hydration. An\r\n * alternative implementation could rely on CSSMediaRule, allowing groups to be\r\n * treated as a sub-sheet, but the Edge implementation of CSSMediaRule is\r\n * broken.\r\n * https://developer.mozilla.org/en-US/docs/Web/API/CSSMediaRule\r\n * https://gist.github.com/necolas/aa0c37846ad6bd3b05b727b959e82674\r\n */\r\nexport default function createOrderedCSSStyleSheet(sheet: ?CSSStyleSheet) {\r\n  const groups: Groups = {};\r\n  const selectors: Selectors = {};\r\n\r\n  /**\r\n   * Hydrate approximate record from any existing rules in the sheet.\r\n   */\r\n  if (sheet != null) {\r\n    let group;\r\n    slice.call(sheet.cssRules).forEach((cssRule, i) => {\r\n      const cssText = cssRule.cssText;\r\n      // Create record of existing selectors and rules\r\n      if (cssText.indexOf('stylesheet-group') > -1) {\r\n        group = decodeGroupRule(cssRule);\r\n        groups[group] = { start: i, rules: [cssText] };\r\n      } else {\r\n        const selectorText = getSelectorText(cssText);\r\n        if (selectorText != null) {\r\n          selectors[selectorText] = true;\r\n          groups[group].rules.push(cssText);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  function sheetInsert(sheet, group, text) {\r\n    const orderedGroups = getOrderedGroups(groups);\r\n    const groupIndex = orderedGroups.indexOf(group);\r\n    const nextGroupIndex = groupIndex + 1;\r\n    const nextGroup = orderedGroups[nextGroupIndex];\r\n    // Insert rule before the next group, or at the end of the stylesheet\r\n    const position =\r\n      nextGroup != null && groups[nextGroup].start != null\r\n        ? groups[nextGroup].start\r\n        : sheet.cssRules.length;\r\n    const isInserted = insertRuleAt(sheet, text, position);\r\n\r\n    if (isInserted) {\r\n      // Set the starting index of the new group\r\n      if (groups[group].start == null) {\r\n        groups[group].start = position;\r\n      }\r\n      // Increment the starting index of all subsequent groups\r\n      for (let i = nextGroupIndex; i < orderedGroups.length; i += 1) {\r\n        const groupNumber = orderedGroups[i];\r\n        const previousStart = groups[groupNumber].start;\r\n        groups[groupNumber].start = previousStart + 1;\r\n      }\r\n    }\r\n\r\n    return isInserted;\r\n  }\r\n\r\n  const OrderedCSSStyleSheet = {\r\n    /**\r\n     * The textContent of the style sheet.\r\n     */\r\n    getTextContent(): string {\r\n      return getOrderedGroups(groups)\r\n        .map(group => {\r\n          const rules = groups[group].rules;\r\n          return rules.join('\\n');\r\n        })\r\n        .join('\\n');\r\n    },\r\n\r\n    /**\r\n     * Insert a rule into the style sheet\r\n     */\r\n    insert(cssText: string, groupValue: number) {\r\n      const group = Number(groupValue);\r\n\r\n      // Create a new group.\r\n      if (groups[group] == null) {\r\n        const markerRule = encodeGroupRule(group);\r\n        // Create the internal record.\r\n        groups[group] = { start: null, rules: [markerRule] };\r\n        // Update CSSOM.\r\n        if (sheet != null) {\r\n          sheetInsert(sheet, group, markerRule);\r\n        }\r\n      }\r\n\r\n      // selectorText is more reliable than cssText for insertion checks. The\r\n      // browser excludes vendor-prefixed properties and rewrites certain values\r\n      // making cssText more likely to be different from what was inserted.\r\n      const selectorText = getSelectorText(cssText);\r\n      if (selectorText != null && selectors[selectorText] == null) {\r\n        // Update the internal records.\r\n        selectors[selectorText] = true;\r\n        groups[group].rules.push(cssText);\r\n        // Update CSSOM.\r\n        if (sheet != null) {\r\n          const isInserted = sheetInsert(sheet, group, cssText);\r\n          if (!isInserted) {\r\n            // Revert internal record change if a rule was rejected (e.g.,\r\n            // unrecognized pseudo-selector)\r\n            groups[group].rules.pop();\r\n          }\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  return OrderedCSSStyleSheet;\r\n}\r\n\r\n/**\r\n * Helper functions\r\n */\r\n\r\nfunction encodeGroupRule(group) {\r\n  return `[stylesheet-group=\"${group}\"]{}`;\r\n}\r\n\r\nfunction decodeGroupRule(cssRule) {\r\n  return Number(cssRule.selectorText.split(/[\"']/)[1]);\r\n}\r\n\r\nfunction getOrderedGroups(obj: { [key: number]: any }) {\r\n  return Object.keys(obj)\r\n    .map(Number)\r\n    .sort((a, b) => (a > b ? 1 : -1));\r\n}\r\n\r\nconst pattern = /\\s*([,])\\s*/g;\r\nfunction getSelectorText(cssText) {\r\n  const selector = cssText.split('{')[0].trim();\r\n  return selector !== '' ? selector.replace(pattern, '$1') : null;\r\n}\r\n\r\nfunction insertRuleAt(root, cssText: string, position: number): boolean {\r\n  try {\r\n    // $FlowFixMe: Flow is missing CSSOM types needed to type 'root'.\r\n    root.insertRule(cssText, position);\r\n    return true;\r\n  } catch (e) {\r\n    // JSDOM doesn't support `CSSSMediaRule#insertRule`.\r\n    // Also ignore errors that occur from attempting to insert vendor-prefixed selectors.\r\n    return false;\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}